import{CSSMedia}from"./CSSMedia.js";import{CSSModel,Edit}from"./CSSModel.js";import{CSSStyleDeclaration,Type}from"./CSSStyleDeclaration.js";export class CSSRule{constructor(e,t){if(this._cssModel=e,this.styleSheetId=t.styleSheetId,this.styleSheetId){const t=e.styleSheetHeaderForId(this.styleSheetId);this.sourceURL=t.sourceURL}this.origin=t.origin,this.style=new CSSStyleDeclaration(this._cssModel,this,t.style,Type.Regular)}rebase(e){this.styleSheetId===e.styleSheetId&&this.style.rebase(e)}resourceURL(){if(!this.styleSheetId)return"";return this._cssModel.styleSheetHeaderForId(this.styleSheetId).resourceURL()}isUserAgent(){return this.origin===Protocol.CSS.StyleSheetOrigin.UserAgent}isInjected(){return this.origin===Protocol.CSS.StyleSheetOrigin.Injected}isViaInspector(){return this.origin===Protocol.CSS.StyleSheetOrigin.Inspector}isRegular(){return this.origin===Protocol.CSS.StyleSheetOrigin.Regular}cssModel(){return this._cssModel}}class CSSValue{constructor(e){this.text=e.text,e.range&&(this.range=TextUtils.TextRange.fromObject(e.range))}rebase(e){this.range&&(this.range=this.range.rebaseAfterTextEdit(e.oldRange,e.newRange))}}export class CSSStyleRule extends CSSRule{constructor(e,t,s){super(e,t),this._reinitializeSelectors(t.selectorList),this.media=t.media?CSSMedia.parseMediaArrayPayload(e,t.media):[],this.wasUsed=s||!1}static createDummyRule(e,t){const s={selectorList:{selectors:[{text:t}]},style:{styleSheetId:"0",range:new TextUtils.TextRange(0,0,0,0),shorthandEntries:[],cssProperties:[]}};return new CSSStyleRule(e,s)}_reinitializeSelectors(e){this.selectors=[];for(let t=0;t<e.selectors.length;++t)this.selectors.push(new CSSValue(e.selectors[t]))}setSelectorText(e){const t=this.styleSheetId;if(!t)throw"No rule stylesheet id";const s=this.selectorRange();if(!s)throw"Rule selector is not editable";return this._cssModel.setSelectorText(t,s,e)}selectorText(){return this.selectors.map(e=>e.text).join(", ")}selectorRange(){const e=this.selectors[0].range;if(!e)return null;const t=this.selectors.peekLast().range;return new TextUtils.TextRange(e.startLine,e.startColumn,t.endLine,t.endColumn)}lineNumberInSource(e){const t=this.selectors[e];if(!t||!t.range||!this.styleSheetId)return 0;return this._cssModel.styleSheetHeaderForId(this.styleSheetId).lineNumberInSource(t.range.startLine)}columnNumberInSource(e){const t=this.selectors[e];if(!t||!t.range||!this.styleSheetId)return;const s=this._cssModel.styleSheetHeaderForId(this.styleSheetId);return console.assert(s),s.columnNumberInSource(t.range.startLine,t.range.startColumn)}rebase(e){if(this.styleSheetId===e.styleSheetId){if(this.selectorRange().equal(e.oldRange))this._reinitializeSelectors(e.payload);else for(let t=0;t<this.selectors.length;++t)this.selectors[t].rebase(e);for(const t of this.media)t.rebase(e);super.rebase(e)}}}export class CSSKeyframesRule{constructor(e,t){this._cssModel=e,this._animationName=new CSSValue(t.animationName),this._keyframes=t.keyframes.map(t=>new CSSKeyframeRule(e,t))}name(){return this._animationName}keyframes(){return this._keyframes}}export class CSSKeyframeRule extends CSSRule{constructor(e,t){super(e,t),this._reinitializeKey(t.keyText)}key(){return this._keyText}_reinitializeKey(e){this._keyText=new CSSValue(e)}rebase(e){this.styleSheetId===e.styleSheetId&&this._keyText.range&&(e.oldRange.equal(this._keyText.range)?this._reinitializeKey(e.payload):this._keyText.rebase(e),super.rebase(e))}setKeyText(e){const t=this.styleSheetId;if(!t)throw"No rule stylesheet id";const s=this._keyText.range;if(!s)throw"Keyframe key is not editable";return this._cssModel.setKeyframeKey(t,s,e)}}
const SkipSubTreeObject={};export class ESTreeWalker{constructor(e,t){this._beforeVisit=e,this._afterVisit=t||new Function,this._walkNulls=!1}static get SkipSubtree(){return SkipSubTreeObject}setWalkNulls(e){this._walkNulls=e}walk(e){this._innerWalk(e,null)}_innerWalk(e,t){if(!e&&t&&this._walkNulls){const t={raw:"null",value:null,type:"Literal"};e=t}if(!e)return;if(e.parent=t,this._beforeVisit.call(null,e)===ESTreeWalker.SkipSubtree)return void this._afterVisit.call(null,e);const r=_walkOrder[e.type];if(r){if("TemplateLiteral"===e.type){const t=e,r=t.expressions.length;for(let e=0;e<r;++e)this._innerWalk(t.quasis[e],t),this._innerWalk(t.expressions[e],t);this._innerWalk(t.quasis[r],t)}else for(let t=0;t<r.length;++t){const s=e[r[t]];Array.isArray(s)?this._walkArray(s,e):this._innerWalk(s,e)}this._afterVisit.call(null,e)}else console.error("Walk order not defined for "+e.type)}_walkArray(e,t){for(let r=0;r<e.length;++r)this._innerWalk(e[r],t)}}const _walkOrder={AwaitExpression:["argument"],ArrayExpression:["elements"],ArrayPattern:["elements"],ArrowFunctionExpression:["params","body"],AssignmentExpression:["left","right"],AssignmentPattern:["left","right"],BinaryExpression:["left","right"],BlockStatement:["body"],BreakStatement:["label"],CallExpression:["callee","arguments"],CatchClause:["param","body"],ClassBody:["body"],ClassDeclaration:["id","superClass","body"],ClassExpression:["id","superClass","body"],ConditionalExpression:["test","consequent","alternate"],ContinueStatement:["label"],DebuggerStatement:[],DoWhileStatement:["body","test"],EmptyStatement:[],ExpressionStatement:["expression"],ForInStatement:["left","right","body"],ForOfStatement:["left","right","body"],ForStatement:["init","test","update","body"],FunctionDeclaration:["id","params","body"],FunctionExpression:["id","params","body"],Identifier:[],ImportDeclaration:["specifiers","source"],ImportExpression:["source"],ExportAllDeclaration:["source"],ExportDefaultDeclaration:["declaration"],ExportNamedDeclaration:["specifiers","source","declaration"],IfStatement:["test","consequent","alternate"],LabeledStatement:["label","body"],Literal:[],LogicalExpression:["left","right"],MemberExpression:["object","property"],MethodDefinition:["key","value"],NewExpression:["callee","arguments"],ObjectExpression:["properties"],ObjectPattern:["properties"],ParenthesizedExpression:["expression"],Program:["body"],Property:["key","value"],RestElement:["argument"],ReturnStatement:["argument"],SequenceExpression:["expressions"],SpreadElement:["argument"],Super:[],SwitchCase:["test","consequent"],SwitchStatement:["discriminant","cases"],TaggedTemplateExpression:["tag","quasi"],TemplateElement:[],TemplateLiteral:["quasis","expressions"],ThisExpression:[],ThrowStatement:["argument"],TryStatement:["block","handler","finalizer"],UnaryExpression:["argument"],UpdateExpression:["argument"],VariableDeclaration:["declarations"],VariableDeclarator:["id","init"],WhileStatement:["test","body"],WithStatement:["object","body"],YieldExpression:["argument"]};
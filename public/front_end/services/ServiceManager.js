import*as Host from"../host/host.js";export class ServiceManager{createRemoteService(e){if(!this._remoteConnection){const e=Root.Runtime.queryParam("service-backend");if(!e)return console.error("No endpoint address specified"),Promise.resolve(null);this._remoteConnection=new Connection(new RemoteServicePort(e))}return this._remoteConnection._createService(e)}createAppService(e,t){let s=e+".js";const o=Root.Runtime.queryParam("remoteBase"),r=Root.Runtime.queryParam("debugFrontend"),i=Host.InspectorFrontendHost.isUnderTest(),n=[];o&&n.push("remoteBase="+o),r&&n.push("debugFrontend="+r),i&&n.push("isUnderTest=true"),n.length&&(s+="?"+n.join("&"));const c=new Worker(s,{type:"module"});return new Connection(new WorkerServicePort(c))._createService(t)}}export class Connection{constructor(e){this._port=e,this._port.setHandlers(this._onMessage.bind(this),this._connectionClosed.bind(this)),this._lastId=1,this._callbacks=new Map,this._services=new Map}_createService(e){return this._sendCommand(e+".create").then(t=>{if(!t)return console.error("Could not initialize service: "+e),null;const s=new Service(this,e,t.id);return this._services.set(e+":"+t.id,s),s})}_serviceDisposed(e){this._services.delete(e._serviceName+":"+e._objectId),this._services.size||this._port.close()}_sendCommand(e,t){const s=this._lastId++,o=JSON.stringify({id:s,method:e,params:t||{}});return this._port.send(o).then(e=>e?new Promise(e=>this._callbacks.set(s,e)):Promise.resolve(null))}_onMessage(e){let t;try{t=JSON.parse(e)}catch(e){return void console.error(e)}if(t.id)return t.error&&console.error("Service error: "+t.error),this._callbacks.get(t.id)(t.error?null:t.result),void this._callbacks.delete(t.id);const s=t.method.split("."),o=s[0],r=s[1],i=this._services.get(o+":"+t.params.id);i?i._dispatchNotification(r,t.params):console.error("Unable to lookup stub for "+o+":"+t.params.id)}_connectionClosed(){for(const e of this._callbacks.values())e(null);this._callbacks.clear();for(const e of this._services.values())e._dispatchNotification("disposed");this._services.clear()}}export class Service{constructor(e,t,s){this._connection=e,this._serviceName=t,this._objectId=s,this._notificationHandlers=new Map}dispose(){const e={id:this._objectId};return this._connection._sendCommand(this._serviceName+".dispose",e).then(()=>{this._connection._serviceDisposed(this)})}on(e,t){this._notificationHandlers.set(e,t)}send(e,t){return(t=t||{}).id=this._objectId,this._connection._sendCommand(this._serviceName+"."+e,t)}_dispatchNotification(e,t){const s=this._notificationHandlers.get(e);s?s(t):console.error("Could not report notification '"+e+"' on '"+this._objectId+"'")}}export class RemoteServicePort{constructor(e){this._url=e}setHandlers(e,t){this._messageHandler=e,this._closeHandler=t}_open(){return this._connectionPromise||(this._connectionPromise=new Promise(function(e){let t;try{t=new WebSocket(this._url),t.onmessage=function(e){this._messageHandler(e.data)}.bind(this),t.onclose=function(){this._socket||e(!1);this._socketClosed(!!this._socket)}.bind(this),t.onopen=function(){this._socket=t,e(!0)}.bind(this)}catch(t){e(!1)}}.bind(this))),this._connectionPromise}send(e){return this._open().then(()=>!!this._socket&&(this._socket.send(e),!0))}close(){return this._open().then(()=>(this._socket&&(this._socket.close(),this._socketClosed(!0)),!0))}_socketClosed(e){this._socket=null,delete this._connectionPromise,e&&this._closeHandler()}}export class WorkerServicePort{constructor(e){let t;this._worker=e,this._workerPromise=new Promise(e=>t=e),this._worker.onmessage=function(e){if("workerReady"===e.data)return void t(!0);this._messageHandler(e.data)}.bind(this),this._worker.onclose=this._closeHandler}setHandlers(e,t){this._messageHandler=e,this._closeHandler=t}send(e){return this._workerPromise.then(()=>{try{return this._worker.postMessage(e),!0}catch(e){return!1}})}close(){return this._workerPromise.then(()=>(this._worker&&this._worker.terminate(),!1))}}
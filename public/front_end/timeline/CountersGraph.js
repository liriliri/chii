import*as Common from"../common/common.js";import*as PerfUI from"../perf_ui/perf_ui.js";import*as Platform from"../platform/platform.js";import*as TimelineModel from"../timeline_model/timeline_model.js";import*as UI from"../ui/ui.js";import{Events,PerformanceModel,Window}from"./PerformanceModel.js";import{TimelineModeViewDelegate}from"./TimelinePanel.js";export class CountersGraph extends UI.Widget.VBox{constructor(e){super(),this.element.id="memory-graphs-container",this._delegate=e,this._calculator=new Calculator,this._header=new UI.Widget.HBox,this._header.element.classList.add("timeline-memory-header"),this._header.show(this.element),this._toolbar=new UI.Toolbar.Toolbar("timeline-memory-toolbar"),this._header.element.appendChild(this._toolbar.element),this._graphsContainer=new UI.Widget.VBox,this._graphsContainer.show(this.element);const t=new UI.Widget.VBoxWithResizeCallback(this._resize.bind(this));t.show(this._graphsContainer.element),this._createCurrentValuesBar(),this._canvasContainer=t.element,this._canvasContainer.id="memory-graphs-canvas-container",this._canvas=this._canvasContainer.createChild("canvas"),this._canvas.id="memory-counters-graph",this._canvasContainer.addEventListener("mouseover",this._onMouseMove.bind(this),!0),this._canvasContainer.addEventListener("mousemove",this._onMouseMove.bind(this),!0),this._canvasContainer.addEventListener("mouseleave",this._onMouseLeave.bind(this),!0),this._canvasContainer.addEventListener("click",this._onClick.bind(this),!0),this._timelineGrid=new PerfUI.TimelineGrid.TimelineGrid,this._canvasContainer.appendChild(this._timelineGrid.dividersElement),this._counters=[],this._counterUI=[],this._countersByName={},this._countersByName.jsHeapSizeUsed=this._createCounter(Common.UIString.UIString("JS Heap"),Common.UIString.UIString("JS Heap: %s"),"hsl(220, 90%, 43%)",Number.bytesToString),this._countersByName.documents=this._createCounter(Common.UIString.UIString("Documents"),Common.UIString.UIString("Documents: %s"),"hsl(0, 90%, 43%)"),this._countersByName.nodes=this._createCounter(Common.UIString.UIString("Nodes"),Common.UIString.UIString("Nodes: %s"),"hsl(120, 90%, 43%)"),this._countersByName.jsEventListeners=this._createCounter(Common.UIString.UIString("Listeners"),Common.UIString.UIString("Listeners: %s"),"hsl(38, 90%, 43%)"),this._gpuMemoryCounter=this._createCounter(Common.UIString.UIString("GPU Memory"),Common.UIString.UIString("GPU Memory [KB]: %s"),"hsl(300, 90%, 43%)",Number.bytesToString),this._countersByName.gpuMemoryUsedKB=this._gpuMemoryCounter}setModel(e,t){this._model!==e&&(this._model&&this._model.removeEventListener(Events.WindowChanged,this._onWindowChanged,this),this._model=e,this._model&&this._model.addEventListener(Events.WindowChanged,this._onWindowChanged,this)),this._calculator.setZeroTime(e?e.timelineModel().minimumRecordTime():0);for(let e=0;e<this._counters.length;++e)this._counters[e].reset(),this._counterUI[e].reset();if(this.scheduleRefresh(),this._track=t,!t)return;const i=t.syncEvents();for(let e=0;e<i.length;++e){const t=i[e];if(t.name!==TimelineModel.TimelineModel.RecordType.UpdateCounters)continue;const s=t.args.data;if(!s)return;for(const e in s){const i=this._countersByName[e];i&&i.appendSample(t.startTime,s[e])}const r="gpuMemoryLimitKB";r in s&&this._gpuMemoryCounter.setLimit(s[r])}}_createCurrentValuesBar(){this._currentValuesBar=this._graphsContainer.element.createChild("div"),this._currentValuesBar.id="counter-values-bar"}_createCounter(e,t,i,s){const r=new Counter;return this._counters.push(r),this._counterUI.push(new CounterUI(this,e,t,i,r,s)),r}resizerElement(){return this._header.element}_resize(){const e=this._canvas.parentElement;this._canvas.width=e.clientWidth*window.devicePixelRatio,this._canvas.height=e.clientHeight*window.devicePixelRatio,this._calculator.setDisplayWidth(this._canvas.width),this.refresh()}_onWindowChanged(e){const t=e.data.window;this._calculator.setWindow(t.left,t.right),this.scheduleRefresh()}scheduleRefresh(){UI.UIUtils.invokeOnceAfterBatchUpdate(this,this.refresh)}draw(){this._clear();for(const e of this._counters)e._calculateVisibleIndexes(this._calculator),e._calculateXValues(this._canvas.width);for(const e of this._counterUI)e._drawGraph(this._canvas)}_onClick(e){const t=e.x-this._canvasContainer.totalOffsetLeft();let i,s=1/0;for(const e of this._counterUI){if(!e.counter.times.length)continue;const r=e._recordIndexAt(t),n=Math.abs(t*window.devicePixelRatio-e.counter.x[r]);n<s&&(s=n,i=e.counter.times[r])}void 0!==i&&this._delegate.selectEntryAtTime(this._track.events.length?this._track.events:this._track.asyncEvents,i)}_onMouseLeave(e){delete this._markerXPosition,this._clearCurrentValueAndMarker()}_clearCurrentValueAndMarker(){for(let e=0;e<this._counterUI.length;e++)this._counterUI[e]._clearCurrentValueAndMarker()}_onMouseMove(e){const t=e.x-this._canvasContainer.totalOffsetLeft();this._markerXPosition=t,this._refreshCurrentValues()}_refreshCurrentValues(){if(void 0!==this._markerXPosition)for(let e=0;e<this._counterUI.length;++e)this._counterUI[e].updateCurrentValue(this._markerXPosition)}refresh(){this._timelineGrid.updateDividers(this._calculator),this.draw(),this._refreshCurrentValues()}_clear(){const e=this._canvas.getContext("2d");e.clearRect(0,0,e.canvas.width,e.canvas.height)}}export class Counter{constructor(){this.times=[],this.values=[]}appendSample(e,t){this.values.length&&this.values.peekLast()===t||(this.times.push(e),this.values.push(t))}reset(){this.times=[],this.values=[]}setLimit(e){this._limitValue=e}_calculateBounds(){let e,t;for(let i=this._minimumIndex;i<=this._maximumIndex;i++){const s=this.values[i];(void 0===t||s<t)&&(t=s),(void 0===e||s>e)&&(e=s)}return t=t||0,e=e||1,this._limitValue&&(e>.5*this._limitValue&&(e=Math.max(e,this._limitValue)),t=Math.min(t,this._limitValue)),{min:t,max:e}}_calculateVisibleIndexes(e){const t=e.minimumBoundary(),i=e.maximumBoundary();this._minimumIndex=Platform.NumberUtilities.clamp(this.times.upperBound(t)-1,0,this.times.length-1),this._maximumIndex=Platform.NumberUtilities.clamp(this.times.lowerBound(i),0,this.times.length-1),this._minTime=t,this._maxTime=i}_calculateXValues(e){if(!this.values.length)return;const t=e/(this._maxTime-this._minTime);this.x=new Array(this.values.length);for(let e=this._minimumIndex+1;e<=this._maximumIndex;e++)this.x[e]=t*(this.times[e]-this._minTime)}}export class CounterUI{constructor(e,t,i,s,r,n){this._countersPane=e,this.counter=r,this._formatter=n||Number.withThousandsSeparator,this._setting=Common.Settings.Settings.instance().createSetting("timelineCountersGraph-"+t,!0),this._setting.setTitle(t),this._filter=new UI.Toolbar.ToolbarSettingCheckbox(this._setting,t),this._filter.inputElement.classList.add("-theme-preserve");const o=Common.Color.Color.parse(s).setAlpha(.5).asString(Common.Color.Format.RGBA);o&&(this._filter.element.backgroundColor=o,this._filter.element.borderColor="transparent"),this._filter.inputElement.addEventListener("click",this._toggleCounterGraph.bind(this)),e._toolbar.appendToolbarItem(this._filter),this._range=this._filter.element.createChild("span","range"),this._value=e._currentValuesBar.createChild("span","memory-counter-value"),this._value.style.color=s,this.graphColor=s,this.limitColor=Common.Color.Color.parse(s).setAlpha(.3).asString(Common.Color.Format.RGBA),this.graphYValues=[],this._verticalPadding=10,this._currentValueLabel=i,this._marker=e._canvasContainer.createChild("div","memory-counter-marker"),this._marker.style.backgroundColor=s,this._clearCurrentValueAndMarker()}reset(){this._range.textContent=""}setRange(e,t){const i=this._formatter(e),s=this._formatter(t);this._range.textContent=Common.UIString.UIString("[%s – %s]",i,s)}_toggleCounterGraph(e){this._value.classList.toggle("hidden",!this._filter.checked()),this._countersPane.refresh()}_recordIndexAt(e){return this.counter.x.upperBound(e*window.devicePixelRatio,null,this.counter._minimumIndex+1,this.counter._maximumIndex+1)-1}updateCurrentValue(e){if(!this.visible()||!this.counter.values.length||!this.counter.x)return;const t=this._recordIndexAt(e),i=Number.withThousandsSeparator(this.counter.values[t]);this._value.textContent=Common.UIString.UIString(this._currentValueLabel,i);const s=this.graphYValues[t]/window.devicePixelRatio;this._marker.style.left=e+"px",this._marker.style.top=s+"px",this._marker.classList.remove("hidden")}_clearCurrentValueAndMarker(){this._value.textContent="",this._marker.classList.add("hidden")}_drawGraph(e){const t=e.getContext("2d"),i=e.width,s=e.height-2*this._verticalPadding;if(s<=0)return void(this.graphYValues=[]);const r=this._verticalPadding,n=this.counter,o=n.values;if(!o.length)return;const a=n._calculateBounds(),h=a.min,l=a.max;if(this.setRange(h,l),!this.visible())return;const m=this.graphYValues,u=l-h,c=u?s/u:1;t.save(),t.lineWidth=window.devicePixelRatio,t.lineWidth%2&&t.translate(.5,.5),t.beginPath();let d=o[n._minimumIndex],_=Math.round(r+s-(d-h)*c);t.moveTo(0,_);let g=n._minimumIndex;for(;g<=n._maximumIndex;g++){const e=Math.round(n.x[g]);t.lineTo(e,_);const i=o[g];void 0!==i&&(d=i),_=Math.round(r+s-(d-h)*c),t.lineTo(e,_),m[g]=_}if(m.length=g,t.lineTo(i,_),t.strokeStyle=this.graphColor,t.stroke(),n._limitValue){const e=Math.round(r+s-(n._limitValue-h)*c);t.moveTo(0,e),t.lineTo(i,e),t.strokeStyle=this.limitColor,t.stroke()}t.closePath(),t.restore()}visible(){return this._filter.checked()}}export class Calculator{setZeroTime(e){this._zeroTime=e}computePosition(e){return(e-this._minimumBoundary)/this.boundarySpan()*this._workingArea}setWindow(e,t){this._minimumBoundary=e,this._maximumBoundary=t}setDisplayWidth(e){this._workingArea=e}formatValue(e,t){return Number.preciseMillisToString(e-this.zeroTime(),t)}maximumBoundary(){return this._maximumBoundary}minimumBoundary(){return this._minimumBoundary}zeroTime(){return this._zeroTime}boundarySpan(){return this._maximumBoundary-this._minimumBoundary}}